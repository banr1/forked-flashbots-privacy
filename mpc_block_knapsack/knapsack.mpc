import sys
sys.path.append("../MP-SPDZ")
from Compiler.oram import OptimalORAM
from Compiler.types import cfix

def max_knapsack(values, weights, W, n):
    size = n*W
    m = OptimalORAM((n+1)*(W+1))

    @for_range(n+1)
    def _(i):
        @for_range(W+1)
        def _(j):
            @if_e((i == 0).bit_or(j == 0))
            def _():
                m[i*(W+1) + j] = 0
            @else_
            def _():
                condition = weights[i-1] > j
                outcome1 = m[(i-1)*(W+1) + j]
                outcome2 = sfix(m[(i-1)*(W+1) + j]).max(m[(i-1)*(W+1)+(j-weights[i-1])] + values[i-1])
                m[i * (W+1) + j] = condition.if_else(outcome1, outcome2)

    return (m[(n)*(W+1)+(W)], m)

def knapsack_subset(index_i, index_j, m, weights):
    subset = OptimalORAM(3)
    W = index_j
    if index_i == 0:
        return
    counter = MemValue(0)
    while (index_i != 0):
        subset[counter] = (m[index_i * (W+1)+index_j] > m[(index_i-1)*(W+1) + index_j]).if_else(index_i, subset[counter])

        counter += 1
        index_i -= 1

    return subset

        
"""
values = OptimalORAM(size=3)
values[0] = 60
values[1] = 100
values[2] = 120

weights = OptimalORAM(size=3)
weights[0] = 10
weights[1] = 20
weights[2] = 30

W = 50
n = 3
"""

# Ideally, W should be secret-shared but due to MP-SPDZ limitations, need it to be a compile time constant
W = int(program.args[2])
# Ideally, n should be a secret-shared value as we typically don't know upfront how many txs are yet to be included in a block.
# This is just to get around MP-SPDZ limitations around compile time sizes
n = int(program.args[1])

values_tmp = []
weights_tmp = []

for i in range(n):
    values_tmp.extend(sfix.get_input_from(i))
    weights_tmp.extend(sfix.get_input_from(i))

values = Array(n, sfix).create_from(values_tmp)
weights = Array(n, sfix).create_from(weights_tmp)

knapsack_val, m = max_knapsack(values, weights, W, n)
knapsack_subset = knapsack_subset(n, W, m, weights)
print_ln("Maximal knapsack value: %s", knapsack_val.reveal())
@for_range(knapsack_subset.size)
def _(i):
    print_ln("Corresponding knapsack set index %s", knapsack_subset[i].reveal())