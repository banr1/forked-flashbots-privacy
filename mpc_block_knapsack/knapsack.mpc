import sys
sys.path.append("../MP-SPDZ")
from Compiler.oram import OptimalORAM
from Compiler.types import cint

def max_knapsack(values, weights, W, n):
    size = n*W
    # Some arbitrarily high number to initialize the ORAM array with. In practice, this should be exactly of size n*W.
    m = OptimalORAM((n+1)*(W+1))

    @for_range(n+1)
    def _(i):
        @for_range(W+1)
        def _(j):
            @if_e((i == 0).bit_or(j == 0))
            def _():
                m[i*(W+1) + j] = 0
            @else_
            def _():
                condition = weights[i-1] > j
                outcome1 = m[(i-1)*(W+1) + j]
                outcome2 = m[(i-1)*(W+1) + j].max(m[(i-1)*(W+1)+(j-weights[i-1])] + values[i-1])
                m[i * (W+1) + j] = condition.if_else(outcome1, outcome2)

    return (m[(n)*(W+1)+(W)], m)

def knapsack_subset(index_i, index_j, m, weights):
    subset = OptimalORAM(3)
    W = index_j
    if index_i == 0:
        return
    counter = MemValue(0)
    while (index_i != 0):
        subset[counter] = (m[index_i * (W+1)+index_j] > m[(index_i-1)*(W+1) + index_j]).if_else(index_i, subset[counter])

        counter += 1
        index_i -= 1

    return subset

        

values = OptimalORAM(size=3)
values[0] = 60
values[1] = 100
values[2] = 120

weights = OptimalORAM(size=3)
weights[0] = 10
weights[1] = 20
weights[2] = 30

W = 50
n = 3
knapsack_val, m = max_knapsack(values, weights, W, n)
knapsack_subset = knapsack_subset(n, W, m, weights)
print_ln("Maximal knapsack value: %s", knapsack_val.reveal())
@for_range(knapsack_subset.size)
def _(i):
    print_ln("Corresponding knapsack set index %s", knapsack_subset[i].reveal())


"""
print_ln("%s", m[regint(n*1000+W)].reveal())

values = OptimalORAM(10)
weights = OptimalORAM(10)
for i in range(10):
    values[i] = sbitvec.get_type(1000).get_input_from(i)
    weights[i] = sbitvec.get_type(1000).get_input_from(i)

# Is currently a clear integer. In a real world deployment, it should be a secret-shared integer. Problem is that you can't loop over secret-shared integers
n = public_input()
W = public_input()
size = n*W
# Some arbitrarily high number to initialize the ORAM array with. In practice, this should be exactly of size n*W.
m = OptimalORAM(1000*1000)

@for_range(1, n)
def _(i):
    @for_range(1, W)
    def _(j):
        tmp_j = regint.bit_decompose(j)
        tmp_j = [sbit(x) for x in tmp_j]
        tmp_j = sbitvec.from_vec(tmp_j)
        condition = weights[i] > tmp_j
        outcome1 = m[(i-1)*1000+j]
        outcome2 = m[(i-1)*1000+j].max(m[(i-1)*1000+(j - weights[i] + values[i])])
        m[i*1000+j] = (condition).if_else(outcome1, outcome2)


print_ln("%s", m[regint(n*1000+W)].reveal())

array_of_indices = []

tmp_weight = m[regint((n*1000)+W)]

@for_range(1, n)
def _(i):
    global tmp_weight
    current_value = m[regint(i*1000+W)]
    previous_value = m[regint((i-1)*1000+W)]
    condition = current_value > previous_value
    array_of_indices.append(condition.if_else(sbit(i), sbit(i-1)))
    tmp_weight = condition.if_else(tmp_weight - weights[i], tmp_weight)

print_ln("items: " + " ".join([str(x.reveal()) for x in array_of_indices]))    
"""