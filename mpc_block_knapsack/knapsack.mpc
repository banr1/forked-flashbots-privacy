import sys
sys.path.append("../MP-SPDZ")
from Compiler.oram import OptimalORAM
from Compiler.types import cint

def max_knapsack(values, weights, W, n):
    size = n*W
    # Some arbitrarily high number to initialize the ORAM array with. In practice, this should be exactly of size n*W.
    m = OptimalORAM((n+1)*(W+1))

    @for_range(n+1)
    def _(i):
        @for_range(W+1)
        def _(j):
            condition = weights[i-1] > j
            outcome1 = m[(i-1)*(W+1) + j]
            outcome2 = m[(i-1)*(W+1) + j].max(m[(i-1)*(W+1)+(j-weights[i-1]) + values[i-1]])
            m[i * (W+1) + j] = condition.if_else(outcome1, outcome2)

    return m[(n+1)*(W+1)+(W+1)]

def knapsack_subset():
    pass

values = OptimalORAM(size=3)
values[0] = 60
values[1] = 100
values[2] = 120

weights = OptimalORAM(size=3)
weights[0] = 10
weights[1] = 20
weights[2] = 30

W = 50
n = 3
knapsack_val = max_knapsack(values, weights, W, n)
print_ln("Maximal knapsack value: %s", knapsack_val.reveal())


"""
print_ln("%s", m[regint(n*1000+W)].reveal())

values = OptimalORAM(10)
weights = OptimalORAM(10)
for i in range(10):
    values[i] = sbitvec.get_type(1000).get_input_from(i)
    weights[i] = sbitvec.get_type(1000).get_input_from(i)

# Is currently a clear integer. In a real world deployment, it should be a secret-shared integer. Problem is that you can't loop over secret-shared integers
n = public_input()
W = public_input()
size = n*W
# Some arbitrarily high number to initialize the ORAM array with. In practice, this should be exactly of size n*W.
m = OptimalORAM(1000*1000)

@for_range(1, n)
def _(i):
    @for_range(1, W)
    def _(j):
        tmp_j = regint.bit_decompose(j)
        tmp_j = [sbit(x) for x in tmp_j]
        tmp_j = sbitvec.from_vec(tmp_j)
        condition = weights[i] > tmp_j
        outcome1 = m[(i-1)*1000+j]
        outcome2 = m[(i-1)*1000+j].max(m[(i-1)*1000+(j - weights[i] + values[i])])
        m[i*1000+j] = (condition).if_else(outcome1, outcome2)


print_ln("%s", m[regint(n*1000+W)].reveal())

array_of_indices = []

tmp_weight = m[regint((n*1000)+W)]

@for_range(1, n)
def _(i):
    global tmp_weight
    current_value = m[regint(i*1000+W)]
    previous_value = m[regint((i-1)*1000+W)]
    condition = current_value > previous_value
    array_of_indices.append(condition.if_else(sbit(i), sbit(i-1)))
    tmp_weight = condition.if_else(tmp_weight - weights[i], tmp_weight)

print_ln("items: " + " ".join([str(x.reveal()) for x in array_of_indices]))    
"""