# Pseudo-code.
# TBD how to handle this practically 
import sys
sys.path.append("../flashbots_mpc")
import flashbots_types

def calculate_effective_fee_per_gas(fee_cap, basefee, priority_fee):
    return (basefee + priority_fee > fee_cap).if_else(fee_cap, basefee + priority_fee)

def calculate_miner_fee(fee_cap, basefee, priority_fee):
    return calculate_effective_fee_per_gas(fee_cap, basefee, priority_fee) - basefee

def bundle_scoring(bundle, mempool_txs, coinbase_difference, basefee):
    sum_over_txs_in_bundle = sum([bundle[i][0] * calculate_miner_fee(bundle[i][2], basefee, bundle[i][3]) for i in range(3)])
    txs_in_bundle_and_mempool = sfix.Matrix(3, 4)
    counter = 0
    for i in range(6):
        for j in range(3):
            if bundle[j] == mempool_txs[i]:
                txs_in_bundle_and_mempool[counter] = bundle[j]
                counter += 1
    sum_over_txs_in_bundle_and_mempool = sum([bundle[i][0] * calculate_miner_fee(bundle[i][2], basefee, bundle[i][3]) for i in range(3)])
    sum_of_gas_over_all_txs_in_bundle = sum([bundle[i][0] for i in range(3)])

    score = (coinbase_difference + sum_over_txs_in_bundle - sum_over_txs_in_bundle_and_mempool) / sum_of_gas_over_all_txs_in_bundle
    return score

def score_all_bundles(bundles, mempools, coinbase_differences, basefees):
    return sort([bundle_scoring(bundle, mempool, coinbase_difference, basefee).reveal() for bundle, mempool, coinbase_difference, basefee in zip(bundles, mempools, coinbase_differences, basefees)])

# Load mempool txs
mempool = Matrix(130, 4, cfix)
for j in range(129):
    gas = cint(public_input())
    gas_price = cint(public_input())
    fee_cap = cint(public_input())
    priority_fee = cint(public_input())
    mempool[j] = [gas, gas_price, fee_cap, priority_fee]
    #print_ln("%s", mempool[j])    

# Load searcher txs
bundles = []
coinbase_differences = []
basefees = []
for i in range(10):
    bundle = Matrix(3, 4, sfix)
    #print_ln("%s", sfix.get_input_from(i).reveal())
    for j in range(3):
        bundle[j].input_from(i)
        bundles.append(bundle)
    #coinbase_differences.append(sfix.get_input_from(i))
    #basefees.append(sfix.get_input_from(i))

#scores = score_all_bundles(bundles, mempools, coinbase_differences, basefees)
#for score in scores:
#    print_ln("score: %s", score)

