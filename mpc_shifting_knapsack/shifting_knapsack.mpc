import math


program.use_edabit(True)


def show_matrix(m):
    for i in range(len(m)):
        print_ln("%s ", m[i].reveal())
    print_ln("")


def knapsack(weights, values, C):
    '''
    The recursive param is to choose if solving the problem using the iterative
    version or the recursive one.
    '''
    N = len(weights)
    lwC = math.ceil(math.log2(C + 1)) + 1
    ret = Array(1, sint)
    ret[0] = 0

    dp = Matrix(2, C + 1, sint)
    dp.assign_all(0)

    @for_range(N)
    def _(i):
        @for_range(C + 1)
        def _(j):
            dp[i % 2][j] = dp[(i + 1) % 2][j]

        cyclic_shift(dp[(i + 1) % 2], C + 1 - weights[i], lwC)

        @for_range(C + 1)
        def _(j):
            opt2 = dp[(i + 1) % 2][j] + values[i]
            should_mov = (j >= weights[i]) * (opt2 > dp[i % 2][j])

            dp[i % 2][j] = should_mov.if_else(opt2, dp[i % 2][j])

        increased = dp[i % 2][C] > ret[0]

        ret[0] = increased.if_else(dp[i % 2][C], ret[0])
        
        show_matrix(dp)

    return ret[0]


def cyclic_shift(values, K, max_log_K):
    K = sint(K) 

    @for_range(max_log_K)
    def _(i):
        should_mov = (K.bit_and(cint(1 << (max_log_K - i - 1)))) != 0

        maybe_shift_by_k(should_mov, values, 1 << (max_log_K - i - 1), 0,
                         len(values))

        print_ln("Power: %s", 1 << (max_log_K - i - 1))

        print_ln("%s XOR %s = %s", 
                 K.reveal(), 
                 1 << (max_log_K - i - 1), 
                 K.bit_xor(1 << (max_log_K - i - 1)).reveal())
        sK = K.bit_xor(1 << (max_log_K - i - 1))

        K.update(should_mov.if_else(sK, K))


def is_base_case(K, start, end, n_values):
    # Computations for the base case
    N = end - start
    K = K % N

    return K == 0


def maybe_shift_by_k(enabled, values, K, i, j):
    start = Array(1, cint)
    end = Array(1, cint) 

    start[0] = cint(i)
    end[0] = cint(j)

    K_temp = K
    K = Array(1, cint)
    K[0] = cint(K_temp)

    K2 = Array(1, cint)
    K2[0] = cint(1)

    condition = (1 - is_base_case(K[0], start[0], end[0], len(values))) * (K2[0] != 0)

    @while_do(lambda: condition)
    def _():
        N = end[0] - start[0]
        K[0] = K[0] % N
        
        @for_range(N - K[0])
        def _(l):
            aux = values[start[0] + ((l + K[0]) % N)]
            values[start[0] + ((l + K[0]) % N)] = enabled.if_else(
                values[start[0] + l],
                values[start[0] + ((l + K[0]) % N)]
            )

            values[start[0] + l] = enabled.if_else(aux, values[start[0] + l]) 

        # Condition for next iteration
        K2[0] = (K[0] - (N % K[0])) % K[0]

        # Definition of subproblem
        start[0] = end[0] - K[0]
        K[0] = K2[0]

        condition.update((1 - is_base_case(K[0], start[0], end[0], len(values))) * (K2[0] != 0))


W = 10
n = 5

values = Array(n, sint)
weights = Array(n, sint)

for i in range(n):
    values[i] = sint.get_input_from(i)
    weights[i] = sint.get_input_from(i)

print_ln("Values: %s", values.reveal())
print_ln("Weights: %s", weights.reveal())

knapsack_value = knapsack(weights, values, W)

print_ln("Knapsack value: %s", knapsack_value.reveal())

