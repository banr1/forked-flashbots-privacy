
sfix.round_nearest = True
cfix.set_precision(f=16, k=80)
sfix.set_precision(f=16, k=80)

class Bidder:
    def __init__(self, id, bid, block_space):
        self.bidder_id = id
        self.bid = sfix(bid)
        self.wanted_block_space = sfix(block_space)
        self.factor = sfix(self.bid/self.wanted_block_space)

def knapsack_auction(bidders, max_block_space, highest_bidder):
    actual_capacity_of_solution = 0
    actual_solution = []
    counter = 0

    @while_do(actual_capacity_of_solution < max_block_space, actual_capacity_of_solution)
    def _():
        current_bidder = bidders[counter]
        actual_solution.append(current_bidder)  
        counter += 1
        actual_capacity_of_solution += current_bidder[2]
        return actual_capacity_of_solution

    surplus = 0
    for winner in actual_solution:
        surplus += winner[1]
    if highest_bidder > surplus:
        return highest_bidder
    else:
        return actual_solution

bidders = []
for i in range(10):
    bid = sfix.get_input_from(i)
    block_space = sfix.get_input_from(i)
    bidder = Bidder(i, bid, block_space)
    bidders.append(bidder)

bidder_matrix = sfix.Matrix(10, 4)
counter = 0
for bidder in bidders:
    vec = sfix.Array(4)
    vec.assign([bidder.bidder_id, bidder.bid, bidder.wanted_block_space, bidder.factor])
    bidder_matrix[counter] = vec.get_reverse_vector()
    counter += 1

bidder_matrix.sort()
highest_bidder = bidder_matrix[0]

knapsack_auction_sol = knapsack_auction(bidder_matrix,30000000,highest_bidder)
if type(knapsack_auction_sol) == list:
    print_ln("Knapsack Auction Winners:")
    for bidder in knapsack_auction_sol:
        print_ln("%s %s %s", bidder[0].reveal(), bidder[1].reveal(), bidder[2].reveal())
else:
    print_ln("Winner is bidder %s with bid %s and wanted block space %s", knapsack_auction_sol[0].reveal(), knapsack_auction_sol[1].reveal(), knapsack_auction_sol[2].reveal())
