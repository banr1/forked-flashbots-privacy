
sfix.round_nearest = True
cfix.set_precision(f=16, k=80)
sfix.set_precision(f=16, k=80)

class Bidder:
    def __init__(self, id, bid, block_space):
        self.bidder_id = id
        self.bid = sfix(bid)
        self.wanted_block_space = sfix(block_space)
        self.factor = sfix(self.bid/self.wanted_block_space)

def knapsack_auction(bidders, max_block_space, highest_bidder): 
    actual_capacity_of_solution = MemValue(sfix(0))
    actual_solution = []
    #global counter
    #counter = MemValue(0)
    n_bidders = bidders.sizes[0]

    @while_do(lambda x: x < n_bidders, regint(0))
    def _(i):
        #nonlocal actual_capacity_of_solution
        current_bidder = bidders[i]
        actual_solution.append(current_bidder)  
        actual_capacity_of_solution.iadd(current_bidder[2])
        return i+1

    surplus = 0
    for winner in actual_solution:
        surplus += winner[1]

    @if_e(highest_bidder[1].reveal() > surplus.reveal())
    def _():
        print_ln("Winner is bidder %s with bid %s and wanted block space %s", highest_bidder[0].reveal(), highest_bidder[1].reveal(), highest_bidder[2].reveal())
    @else_
    def _():
        print_ln("Knapsack Auction Winners:")
        for bidder in actual_solution:
            print_ln("%s %s %s", bidder[0].reveal(), bidder[1].reveal(), bidder[2].reveal())

bidders = []
for i in range(10):
    bid = sfix.get_input_from(i)
    block_space = sfix.get_input_from(i)
    bidder = Bidder(i, bid, block_space)
    bidders.append(bidder)

bidder_matrix = sfix.Matrix(10, 4)
counter = 0
for bidder in bidders:
    vec = sfix.Array(4)
    vec.assign([bidder.bidder_id, bidder.bid, bidder.wanted_block_space, bidder.factor])
    bidder_matrix[counter] = vec.get_reverse_vector()
    counter += 1

bidder_matrix.sort()
highest_bidder = bidder_matrix[0]

knapsack_auction(bidder_matrix,30000000,highest_bidder)